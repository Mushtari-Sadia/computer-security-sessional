# -*- coding: utf-8 -*-
"""BitVectorDemo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NoLVEBqkvrHwoYoEuxX0BeJvaJ5MtVrA
"""

# !pip install BitVector


"""Tables"""

from math import ceil,floor
import numpy as np
import copy
import time
from BitVector import *
import binascii
import os

def processMedia(filename):
        with open(filename, 'rb') as f:
            content = f.read()
        hextext = str(binascii.hexlify(content))
        hextext = hextext[2:] 
        hextext = hextext[:-1]
        print("file plain text",hextext)
        return getBlocks(hextext)

def getBlocks(key):
        blocks = []
        if len(key)*4 < 128 :
            key_len = 128 - len(key)*4
            key = "0"*floor(key_len/4) + key
            blocks.append(key)

        
        elif len(key)*4 > 128 :
            number_of_blocks = len(key)*4/128
            extra=0
            if number_of_blocks.is_integer():
                number_of_blocks = int(number_of_blocks)
            else :
                extra = number_of_blocks - floor(number_of_blocks)
                number_of_blocks = floor(number_of_blocks)
            print("number_of_blocks",number_of_blocks)
            end=0
            for i in range(number_of_blocks):
                blocks.append(key[32*i:32*i+32])
                print(blocks[-1])
                end = 32*i+32
            if extra!=0:
                blocks.append(key[end:])
                print(blocks[-1])
        return blocks

def createFileFromDeciphered(decipher,filename):
    data = bytes.fromhex(decipher)
    name = filename.split('/')[-1]
    os.makedirs("recvd_media/", exist_ok=True)
    with open("recvd_media/"+name, 'wb') as file:
        file.write(data)

class AES:
    Sbox = (
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
    )

    InvSbox = (
        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
    )

    Mixer = [
        [BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01")],
        [BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01")],
        [BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03")],
        [BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02")]
    ]

    InvMixer = [
        [BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09")],
        [BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D")],
        [BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B")],
        [BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E")]
    ]

    rc = [BitVector(hexstring="01"),BitVector(hexstring="02"),BitVector(hexstring="04"),
        BitVector(hexstring="08"),BitVector(hexstring="10"),BitVector(hexstring="20")
        ,BitVector(hexstring="40"),BitVector(hexstring="80"),BitVector(hexstring="1B")
        ,BitVector(hexstring="36"),BitVector(hexstring="6C"),BitVector(hexstring="D8"),BitVector(hexstring="AB")
        ,BitVector(hexstring="4D")]

    times = {}

    AES_modulus = BitVector(bitstring='100011011')
    rounds = {128 : 10, 192 : 12, 256 : 14}
    key_length = 128

    def setInitialText(self,text):
        self.initial_text_ascii = text
        self.initial_text = self.initial_text_ascii.encode("utf-8").hex()
        self.initial_text = self.check_length(self.initial_text)
        self.text_to_matrix(self.initial_text)
    
    def setInitialTextinHex(self,texthex):
        self.initial_text = texthex
        self.initial_text = self.check_length(self.initial_text)
        self.text_to_matrix(self.initial_text)
    
    def setKey(self,key):
        self.initial_roundkey_ascii = key
        self.initial_roundkey = self.initial_roundkey_ascii.encode("utf-8").hex()
        self.initial_roundkey = self.check_key_length(self.initial_roundkey)
    
    def setKeyLength(self,length):
        self.rounds = {128 : 10, 192 : 12, 256 : 14}
        self.key_length = length

    def check_length(self,key) : 
        if len(key)*4 < 128 :
            key_len = 128 - len(key)*4
            key = "0"*floor(key_len/4) + key

        elif len(key)*4 > 128 :
            key_len = len(key)*4 - 128
            # print(key_len)
            key = key[0:-ceil(key_len/4)]
        
        # print(key)    
        # print(len(key)*4,"bits")
        return key
    
    
            
    
    def check_key_length(self,key) :
        length = self.key_length
        if len(key)*4 < length :
            key_len = length - len(key)*4
            key = "0"*floor(key_len/4) + key

        elif len(key)*4 > length :
            key_len = len(key)*4 - length
            # print(key_len)
            key = key[0:-ceil(key_len/4)]
        
        # print(key)    
        # print(len(key)*4,"bits")
        return key

    def text_to_matrix(self,text):
        state_matrix = [[],[],[],[]]
        i,l=0,0
        while l<32 :
            state_matrix[i].append(BitVector(hexstring=text[l:l+2]))
            l=l+2
            if l%8==0:
                i=i+1
        self.state_matrix = state_matrix

    

    def circular_byte_left_shift(self,w,offset) :
        for i in range(offset):
            w.append(w.pop(0))

    def circular_byte_right_shift(self,w,offset) :
        for i in range(offset):
            last = w.pop()
            w = [last,*w]
        return w

    def byte_substitution(self,w):
        for i in range(len(w)):
            b = w[i]
            int_val = b.intValue()
            s = self.Sbox[int_val]
            s = BitVector(intVal=s, size=8)
            # print(i,s.get_bitvector_in_hex())
            w[i] = s

    def add_round_constant(self,w,round) :
        w[0] = w[0]^self.rc[round]

    def g(self,w,round) :
        x = copy.deepcopy(w)
        self.circular_byte_left_shift(x,1)
        self.byte_substitution(x)
        self.add_round_constant(x,round)
        return x

    def print_w(self,w) :
        for j in range(4) :
            print(w[j].get_bitvector_in_hex(),end=' ')

    def mix_columns(self,state_matrix,inv=False) :
        matrix = self.Mixer
        if inv:
            matrix = self.InvMixer
        x = BitVector(hexstring="00")
        result = [[],[],[],[]]
        for i in range(4):
            for j in range(4):
                result[i].append(x)
        for i in range(len(matrix)):
            for j in range(len(state_matrix[0])):
                for k in range(len(state_matrix)):
                    result[i][j] = result[i][j]^matrix[i][k].gf_multiply_modular(state_matrix[k][j], self.AES_modulus, 8)
        return result

    def add_roundkey(self,roundkey,state_matrix):
        l=0
        w = [[],[],[],[]]
        i=0
        while l<32 :
            w[i].append(BitVector(hexstring=roundkey[l:l+2]))
            l=l+2
            if l%8==0:
                i=i+1

        for i in range(4):
            for j in range(4):
                state_matrix[i][j] = state_matrix[i][j]^w[i][j]

    def key_scheduling(self):
        roundkeys = []
        roundkeys.append(self.initial_roundkey)
        roundkey = self.initial_roundkey
        # print("self.initial_roundkey",self.initial_roundkey)
        for round in range(self.rounds[self.key_length]):
            l=0
            w = [[]] * 4
            i=0
            while l<32 :
                w[i].append(BitVector(hexstring=roundkey[l:l+2])) 
                l=l+2
                if l%int(self.key_length/16)==0:
                    i=i+1
            for i in range(4):
                w.append([])
            
            elements = int(self.key_length/32)

            for i in range(elements):
                w[4].append(w[0][i]^self.g(w[3],round)[i])
            # print_w(w[4])
            for i in range(elements):
                w[5].append(w[4][i]^w[1][i])
            for i in range(elements):
                w[6].append(w[5][i]^w[2][i])
            for i in range(elements):
                w[7].append(w[3][i]^w[6][i])
            
            roundkey = ""
            for i in range(4):
                for j in range(elements):
                    roundkey += w[4+i][j].get_bitvector_in_hex()
            roundkeys.append(roundkey)
        self.roundkeys = roundkeys
            

    def encryption(self):
        self.add_roundkey(self.roundkeys[0],self.state_matrix)
        state_matrix = self.state_matrix
        for round in range(1,self.rounds[self.key_length]+1):
            #Sbox substitution
            for i in range(4) :
                for j in range(4):
                    int_val = state_matrix[i][j].intValue()
                    s = self.Sbox[int_val]
                    s = BitVector(intVal=s, size=8)
                    state_matrix[i][j] = s

            #transpose to make column major order
            state_matrix = list(map(list, zip(*state_matrix)))
            
            #shift row
            for i in range(4):
                self.circular_byte_left_shift(state_matrix[i],i)
            
            #mix columns
            if round!=self.rounds[self.key_length]:
                state_matrix = self.mix_columns(state_matrix)
            
            
            #transpose to make row major order
            state_matrix = list(map(list, zip(*state_matrix)))
            self.add_roundkey(self.roundkeys[round],state_matrix)

            #transpose to make column major order and print
            # print_matrix = list(map(list, zip(*state_matrix)))
            # print("round",round)
            # for i in range(4):
            #     print_w(print_matrix[i])
            #     print()
            # print()
        self.state_matrix = state_matrix


    def decryption(self):
        self.add_roundkey(self.roundkeys[self.rounds[self.key_length]],self.state_matrix)
        state_matrix = self.state_matrix

        for round in range(1,self.rounds[self.key_length]+1):
            #transpose to make column major order
            state_matrix = list(map(list, zip(*state_matrix)))
            
            #inverse shift row
            for i in range(4):
                state_matrix[i] = self.circular_byte_right_shift(state_matrix[i],i)
            # print("inverse shift row")
            # for i in range(4):
            #     print_w(state_matrix[i])
            #     print()
            # print()

            #inverse Sbox substitution
            for i in range(4) :
                for j in range(4):
                    int_val = state_matrix[i][j].intValue()
                    s = self.InvSbox[int_val]
                    s = BitVector(intVal=s, size=8)
                    state_matrix[i][j] = s
            # print("inverse sbox sub")
            # for i in range(4):
            #     print_w(state_matrix[i])
            #     print()
            # print()

        #transpose to make row major order
            state_matrix = list(map(list, zip(*state_matrix)))
            self.add_roundkey(self.roundkeys[self.rounds[self.key_length]-round],state_matrix)

            # print("add roundkey",roundkeys[10-round])
            # for i in range(4):
            #     print_w(state_matrix[i])
            #     print()
            # print()
            #transpose to make column major order
            state_matrix = list(map(list, zip(*state_matrix)))
            #inverse mix columns
            if round!=self.rounds[self.key_length]:
                state_matrix = self.mix_columns(state_matrix,True)
            
            # print("inverse mix column")
            # for i in range(4):
            #     print_w(state_matrix[i])
            #     print()
            # print()

            #transpose to make column major order and print
            state_matrix = list(map(list, zip(*state_matrix)))
            # print("round",round)
            # for i in range(4):
            #     print_w(state_matrix[i])
            #     print()
            # print()
        self.state_matrix = state_matrix
    
    def createCipherText(self):
        self.key_scheduling()
        self.encryption()
        self.ciphertexthex=""
        self.ciphertext=""
        for i in range(4):
            for j in range(4):
                self.ciphertexthex += self.state_matrix[i][j].get_bitvector_in_hex()
                self.ciphertext += self.state_matrix[i][j].get_bitvector_in_ascii()
    
    def createDecipheredText(self):
        self.key_scheduling()
        self.text_to_matrix(self.ciphertexthex)
        self.decryption()
        self.decipheredtexthex=""
        self.decipheredtext=""
        for i in range(4):
            for j in range(4):
                self.decipheredtexthex += self.state_matrix[i][j].get_bitvector_in_hex()
                self.decipheredtext += self.state_matrix[i][j].get_bitvector_in_ascii()

    def createDecipheredFile(self,filename):
        self.key_scheduling()
        self.text_to_matrix(self.ciphertexthex)
        self.decryption()
        self.decipheredtexthex=""
        for i in range(4):
            for j in range(4):
                self.decipheredtexthex += self.state_matrix[i][j].get_bitvector_in_hex()

        data = bytes.fromhex(self.decipheredtexthex)
        
        name = filename.split('/')[-1]
        os.makedirs("media/", exist_ok=True)
        with open("media/"+name, 'wb') as file:
            file.write(data)

    def aesEncryptionDecryption(self):
        print("\n\nPlain Text:")
        print(self.initial_text_ascii,"[In ASCII]")
        print(self.initial_text,"[In HEX]")

        print("Key:")
        print(self.initial_roundkey_ascii,"[In ASCII]")
        print(self.initial_roundkey,"[In HEX]")
        print(len(self.initial_roundkey)*4,"[key length]")

        start_time = time.time()
        self.key_scheduling()
        end_time = time.time()
        self.times['Key Scheduling'] = end_time-start_time


        start_time = time.time()
        self.encryption()
        end_time = time.time()
        self.times['Encryption'] = end_time-start_time

        self.ciphertexthex=""
        self.ciphertext=""
        for i in range(4):
            for j in range(4):
                self.ciphertexthex += self.state_matrix[i][j].get_bitvector_in_hex()
                self.ciphertext += self.state_matrix[i][j].get_bitvector_in_ascii()

        print("Cipher Text:")
        print(self.ciphertexthex," [IN HEX]")
        print(self.ciphertext," [IN ASCII]")


        self.text_to_matrix(self.ciphertexthex)
        start_time = time.time()
        self.decryption()
        end_time = time.time()
        self.times['Decryption'] = end_time-start_time


        self.decipheredtexthex=""
        self.decipheredtext=""
        for i in range(4):
            for j in range(4):
                self.decipheredtexthex += self.state_matrix[i][j].get_bitvector_in_hex()
                self.decipheredtext += self.state_matrix[i][j].get_bitvector_in_ascii()


        print("Deciphered Text:")
        print(self.decipheredtexthex," [IN HEX]")
        print(self.decipheredtext," [IN ASCII]")

        print("Execution Time:")
        print(self.times)


# initial_text = input("Plain Text :")
# initial_roundkey = input("Key:\n")

#bonus 2
# initial_text = "CanTheyDoTheirFest?"
# initial_roundkey = "BUET CSE17 Batch is the best"
# key_length = 256
# aes = AES()
# aes.setInitialText(initial_text)
# aes.setKeyLength(key_length)
# aes.setKey(initial_roundkey)
# aes.aesEncryptionDecryption()


# #bonus 1
# filename = input("Input Filepath :")
# initial_roundkey = input("Key:\n")

# blocks = processMedia(filename)
# decipheredText = ""

# stage=0
# for block in blocks :
#     aes = AES()
#     aes.setInitialTextinHex(block)
#     aes.setKey(initial_roundkey)
#     # print("stage",stage,": encryption beginning..")
#     aes.createCipherText()
#     # print("stage",stage,": encryption completed.")
#     aes.createDecipheredText()
#     print("stage",stage,": completed.")
#     decipheredText += aes.decipheredtexthex
#     stage += 1

# print("decipheredText",decipheredText)
# createFileFromDeciphered(decipheredText,filename)



